#pragma config(Sensor, S1,     sensorColor,    sensorColorNxtFULL)
#pragma config(Sensor, S2,     Sonar,          sensorSONAR)
#pragma config(Sensor, S3,     LichtL,         sensorLightActive)
#pragma config(Sensor, S4,     LichtR,         sensorLightActive)
#pragma config(Motor,  motorA,          MotorLinks,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Head,          tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          MotorRechts,   tmotorNXT, PIDControl)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma systemFile // eliminates warning for "unreferenced" functions
#include "queue.c"

//protoype van functies en tasks.
float get_offset(void);
void turnStreat(void);
void turnLeft(void);
void turnRight(void);
void stop_rij_auto(void);
task rij_auto();
task scancode();
task sonar();


// Globale variable
//float test = 0;
Queue q;
float turn = 0;
int max_light = 0;
int min_light = 0;
float Tp = 60; // target power bij het rechtdoorrijden van de robot.
float Kp = 3.5; // constante varriable die representatief is aan de proportional range van de error (met hoeveel gaat de snelheid omhoog / omlaag per error niveau).
float Ki = 1; // Constante varriable die een correctie geeft voor de integral. deze word grotendeels getweakt via trial en error
float Kd = 55; // Constante varriable die een correctie geeft voor de derivative. Ook deze word grootendeels getweakt via trial en error.
float offset = 0;//get_offset(); // gemiddelde van de minimum en maximum leeswaardes van de sensor ((minlicht + maxlicht) / 2) + 2
float integral = 0; // corriectiewaarde die aan de error word toegevoegd om te compenseren voor het "verleden"
float perverror = 0; //hierin word de error opgeslagen uit de vorrige scanloop om de derivative mee te berekenen.
float derivative = 0; //correctiewaarde die aan de error word toegevoegd om te "voorspellen" wat te volgende error gaat worden en hier zo goed mogelijk rekening mee te houden.
float error = 0;
int triggerScan = 0;
int telzwart = 0;
int pos = 0;
bool auto = false;

//int array[20];			//debug varriable voor het checken van colorsensoren
//int x = -1;					//
//int len = 20;				//-
//float lightrr = 0; 	//debug varriable voor het checken van lichtsensoren tijdens de rit
//float lightll = 0; 	//debug varriable voor het checken van lichtsensoren tijdens de rit

// Kruispunt functies
void turnRight(void)
{
	motor[MotorRechts] = 0;
	motor[MotorLinks] = 0;

	nMotorEncoderTarget[Head] = 100;
	motor[Head] = 50;
	wait1Msec(2000);

	nMotorEncoderTarget[Head] = 100;
	motor[Head] = -50;
	if(SensorValue[Sonar] > 33)
	{
		nMotorEncoder[MotorLinks] = 0;
		motor[MotorRechts] = -20;
		motor[MotorLinks] = 50;
		while(nMotorEncoder[MotorLinks] < 270){}
	}
	else
	{
		stop_rij_auto();
	}
}

void turnLeft(void)
{
	motor[MotorRechts] = 0;
	motor[MotorLinks] = 0;

	nMotorEncoderTarget[Head] = 100;
	motor[Head] = -50;
	wait1Msec(2000);

	nMotorEncoderTarget[Head] = 100;
	motor[Head] = 50;
	if(SensorValue[Sonar] > 33)
	{
		motor[MotorRechts] = 40;
		motor[MotorLinks] = -10;
		while(SensorValue[LichtL] < offset);
	}
	else
	{
		stop_rij_auto();
	}
}

void turnStreat(void)
{
	motor[MotorRechts] = Tp;
	motor[MotorLinks] = Tp;
	while(SensorValue[LichtL] < offset);
}


float get_offset(void)
{
	//playSound(soundBeepBeep);
	//wait10Msec(500);
	max_light = SensorValue[LichtL];
	min_light = SensorValue[LichtR];
	playSound(soundBeepBeep);
	float offset = ((max_light + min_light) / 2) + 2;
	return offset;
}

void stop_rij_auto(void){
	stopTask(sonar);
	stopTask(scancode);
	stopTask(rij_auto);
	integral = perverror = derivative = error = triggerScan = pos = telzwart = 0;
	auto = false;
	motor[MotorRechts]=0;
	motor[MotorLinks]=0;
}

task rij_auto()
{
	startTask(sonar);
	startTask(scancode);
	wait10Msec(10);
	float speedL = 0, speedR = 0, Grayscale = 0;
	while(true)
	{
		Grayscale = SensorValue[LichtR];
		if (error == 0 || (perverror < 0 && error > 0) || (perverror > 0 && error < 0))
		{
			integral = 0;
		}
		error = Grayscale - offset; // berekent de error value (hoever de sensor van de lijn zit.)
		integral = (2/3)*integral + error; //opsomming van de integrals
		derivative = error - perverror;
		//datalogAddValue(derivative, derivative);
		turn = (Kp * error) + (Ki * integral) + (Kd * derivative); // berekening waarbij bepaald word hoeveel er bijgestuurd moet worden om op de lijn te blijven.

		speedL = (Tp - turn);
		speedR = (Tp + turn);
		//displayString(6, "R= %d, L= %d", speedR, speedL);
		motor[MotorLinks] = speedL;
		motor[MotorRechts] = speedR;
		perverror = error;

		//lightrr = SensorValue[LichtR]; //debug
		//lightll = SensorValue[LichtL]; //debug

		if (SensorValue[LichtL] < offset)
		{
			//switch(pos){
			//case 2:
			//	turnStreat();
			//	break;
			//case 3:
			//	turnRight();
			//	break;
			//case 4:
			//	turnLeft();
			//	break;
			//default:
			//	turnStreat();
			//	break;
			//}
			//pos = 0;
			switch(dequeue(&q)){
			case 1:
			case 2:
				turnStreat();
				break;
			case 3:
				turnLeft();
				break;
			case 4:
				turnRight();
				break;
			default:
				stop_rij_auto();
				break;
			}
		}
	}
}


task scancode()
{                           							 //deze task leest de sensor in en houd bij wanneer er een verandering in kleur op treed
	int Kleur = 0;
	while(true)
	{																					 // als er een verandering optreed wordt dit bijgehouden

		Kleur = SensorValue[sensorColor];
		switch(Kleur)
		{
		case 0:
		case 1: //black
			if(triggerScan == 1)
			{
				telzwart = telzwart +1;
			}
			break;

		case 5:	//red
			if(triggerScan == 0)
			{
				triggerScan = 1;
			}
			else
			{
				triggerScan = 0;
				displayString(4, "%d", telzwart);
				pos = telzwart;
				//array[x] = telzwart;
				//if(x < len){
				//	x++;
				//}
				telzwart =0;
			}
		}
		while(SensorValue[sensorColor] == Kleur);
		wait1Msec(20);
	}
}

task sonar()
{
	while (true)
	{
		//test = nMotorEncoder[Head];
		//if(turn > 5 && test < 5 && test <= 50){//L
		//	nMotorEncoderTarget[Head] = 50;
		//	motor[Head] = 100;
		//	wait1Msec(500);
		//	} else if(turn < -5 && test > -5 && test <= 50){//r
		//	motor[Head] = -100;
		//	wait1Msec(500);
		//}
		if (SensorValue[Sonar] <= 30)
		{
			stop_rij_auto();
		}
	}
}

task main()
{
	int mailbox = 5;
	string btmessage="";
	nMotorEncoder[Head] = 0;
	init_queue(&q);

	while(true)
	{
		// lees mailbox
		int a = cCmdMessageGetSize(mailbox);  //haal de hoeveel bytes in eerst volgende bericht
		if(a > 0)
		{
			cCmdMessageRead(btmessage, a, mailbox); // lees aantal bytes a in en plaats ze in btmessage

			if(btmessage == "AUTO")
			{
				auto = true;
				startTask(rij_auto);
			}
			else if(btmessage == "MANUAL")
			{
				stop_rij_auto();
			}
			else if(btmessage == "CALIBRATE")
			{
				stop_rij_auto();
				offset = get_offset();
			}
			else if(!auto)
			{
				if(btmessage == "UP")
				{
					motor[MotorRechts]=100;
					motor[MotorLinks]=100;
				}
				else if(btmessage == "DOWN")
				{
					motor[MotorRechts]=-100;
					motor[MotorLinks]=-100;
				}
				else if(btmessage == "LEFT")
				{
					motor[MotorRechts]=100;
					motor[MotorLinks]=-100;
				}
				else if(btmessage == "RIGHT")
				{
					motor[MotorRechts]=-100;
					motor[MotorLinks]=100;
				}
				else if(btmessage == "NULL")
				{
					motor[MotorRechts]=0;
					motor[MotorLinks]=0;
				}
			}
			else
			{
				if(btmessage == "UP")
				{
					enqueue(&q, 1);
				}
				else if(btmessage == "DOWN")
				{
					enqueue(&q, 2);
				}
				else if(btmessage == "LEFT")
				{
					enqueue(&q, 3);
				}
				else if(btmessage == "RIGHT")
				{
					enqueue(&q, 4);
				}
			}
			btmessage="";
		}
	}
}
