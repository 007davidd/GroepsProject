#pragma config(Sensor, S1,     sensorColor,    sensorColorNxtFULL)
#pragma config(Motor,  motorA,          MotorLinks,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          MotorRechts,   tmotorNXT, PIDControl)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int speedR = 0;           //speed motorR
int speedL = 0;						//speed motorL
string vorigekleur = ""; 	//variabele om de vorige kleur in op te slaan
int len = 20;							// lengte van de array
int array[20];          	 //array waar de gescande kleuren in opgeslagen worden

int x=0;              		//varibale die volgende positie in array aanwijst;
int scanPauze = 50; 			//variabele die scan interval regelt

int wit = 0;


task rij(){

	wait1Msec(100);

	while(speedR < 100 && speedL < 100){
		speedR = speedR +5;
		speedL = speedL +5;
		motor[MotorRechts]=speedR;
		motor[MotorLinks]=speedL;

		wait1Msec(50);
	}
}

task leesKleur(){                             //deze task leest de sensor in en houd bij wanneer er een verandering in kleur op treed
	while(true){																// als er een verandering optreed wordt dit bijgehouden
		eraseDisplay();
		string sColor;

		switch(SensorValue[sensorColor]){

		case 0:
			sColor = "Black";
			if(vorigekleur == "Black"){
				//kleur is zelfde als in geen nieuw blokje gevonden
			}
			else{
				if(vorigekleur == "White"){
						vorigekleur = "Black";
						wait1Msec(scanPauze);																										//	hier moet de kleur toegevoegd worden aan de queu																									// zet de vorige kleur gelijk aan de huidige kleur
				}
			}
			break;

		case 2:
			sColor = "Blue";
			if(vorigekleur == "Blue"){

			}
			else{
				if(vorigekleur == "White"){
						vorigekleur = "Blue";
						if(x<len){
							array[x] = 40;
							x++;
							wait1Msec(scanPauze);

						}
				}
		 }
		 break;

		case 3:
			sColor = "Green";
			if(vorigekleur == "Green"){

			}
			else{
				if(vorigekleur == "White"){
						vorigekleur = "Green";
						if(x<len){
								array[x] = 30;
								x++;
								wait1Msec(scanPauze);
						}
				}
		 }
		break;


		case 4:
			sColor = "Yellow";
			if(vorigekleur == "Yellow"){

			}
			else{
				if(vorigekleur == "White"){
						vorigekleur = "Yellow";
						if(x<len){
							array[x] = 20;
							x++;
							wait1Msec(scanPauze);
						}
				}
		  }
			break;

		case 5:
			sColor = "Red";
			if(vorigekleur == "Red"){
						//doe niets dubbele scan
			}
			else{
				if(vorigekleur == "White"){  //if vorige kleur is white dan pas mag rood of andere kleur ingelezen worden
							vorigekleur = "Red";
							if(x<len){
								array[x] = 10;
								x++;
								wait1Msec(scanPauze);
							}
				}
		  }
			break;

		case 6:
			sColor = "White";
			if(vorigekleur == "White"){

			}
			else{
				vorigekleur = "White";
				wit++;
			}
			break;

			/*
			default:
			sColor = "???";
			if(vorigekleur == "???"){
			//kleur is zelfde als in geen nieuw blokje gevonden
			}
			else{
			playTone(soundBlip);  //indicatie er is een nieuwe kleur gevonden
			vorigekleur = "???"; // zet de vorige kleur gelijk aan de huidige kleur
			}
			break; */

		}

		nxtDisplayCenteredTextLine(2, sColor);

	}
}

task main()
{
	startTask(leesKleur);
	startTask(rij);
	while(true){}
}

//rood is 10
//geel is 20
//groen is 30
//blauw is 40
